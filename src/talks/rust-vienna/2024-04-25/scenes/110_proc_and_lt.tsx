import { Code, CODE, LezerHighlighter, Layout, makeScene2D, Rect, Txt, lines } from "@motion-canvas/2d";
import { DEFAULT, all, beginSlide, chain, createRef, createRefArray, range, easeOutQuad, waitFor } from "@motion-canvas/core";
import { parser } from '@lezer/rust';

import { parser as pyParser } from '@lezer/python';

import { DEFAULT_COLOR_BACKGROUND, DEFAULT_FONT, NOBREAK_SPACE } from "./defaults";

Code.defaultHighlighter = new LezerHighlighter(parser);

const PythonHighlighter = new LezerHighlighter(pyParser);

export default makeScene2D(function*(view) {
  view.fill(DEFAULT_COLOR_BACKGROUND)

  const baseLayout = createRef<Layout>();
  const innerLayout = createRef<Layout>();

  const title = createRef<Txt>();
  let titleTo = "Procedural Macros\nSmart Pointers";

  const subItems = createRefArray<Txt>();

  view.add(
    <Layout
      ref={baseLayout}
      fontFamily={DEFAULT_FONT}
      width={"80%"}
      height={"60%"}
      direction={"row"}
      alignItems={"center"}
      layout
    >
      <Rect
        ref={innerLayout}
        width={"100%"}
        direction={"column"}
        alignItems={"start"}
        layout
      >
        <Txt
          ref={title}
          width={"100%"}
          fontSize={120}
          fill={"white"}
        />
        {range(5).map(() => (
          <Txt
            ref={subItems}
            fontSize={65}
            fill={"white"}
          />
        ))}
      </Rect>
    </Layout>
  );

  title().height(baseLayout().height() * 0.25);

  // Helpers for items below title

  const displaySubItem = function*(index: number, text: string, totalDuration: number = 2.0) {
    yield* chain(
      subItems[index].height(baseLayout().height() * 0.2, totalDuration * 0.25),
      subItems[index].text(text, totalDuration * 0.75),
    );
  };

  const hideSubItem = function*(index: number, totalDuration: number = 2.0) {
    yield* chain(
      subItems[index].text("", totalDuration * 0.25),
      subItems[index].height(0, totalDuration * 0.75),
    );
  }

  // Expectations

  yield* beginSlide("proc_and_lt");

  const underscores = titleTo.split("\n").map(part => "_".repeat(part.length)).join("\n");

  yield* all(
    title().opacity(1, 1),
    title().text(underscores, 1).to(titleTo, 1.5),
  );

  yield* beginSlide("proc_macros");

  yield* title().text("Procedural Macros", 1);

  yield* beginSlide("proc_macro_example");

  yield* title().text("", 1.5, easeOutQuad);

  const codeLayoutRef = createRef<Rect>();
  const codeRef = createRef<Code>();

  view.add(
    <Rect
      ref={codeLayoutRef}
      fontFamily={DEFAULT_FONT}
      width={"95%"}
      height={"60%"}
      alignItems={"center"}
      layout
    >
      <Code
        ref={codeRef}
        fontSize={32}
      />
    </Rect>
  );

  const exampleProcMacro = CODE`\
use pyo3::prelude::*;

#[pyfunction]
fn hello_world() -> String {
    String::from("Hello World!")
}

#[pymodule]
fn my_library(m: &Bound<'_, PyModule>) -> PyResult<()> {
    m.add_function(wrap_pyfunction!(hello_world, m)?)?;

    Ok(())
}`;

  const exampleProcMacroExpandedOne = CODE`\
#[allow(clippy::used_underscore_binding)]
fn my_library(m: &Bound<'_, PyModule>) -> PyResult<()> {
    let check_gil_refs = ::pyo3::impl_::deprecations::GilRefs::new();
    let m = ::pyo3::impl_::deprecations::inspect_type(m, &check_gil_refs);
    check_gil_refs.function_arg();
    #[allow(unknown_lints, unused_imports, redundant_imports)]
    use ::pyo3::{types::PyModuleMethods, PyNativeType};
    m.add_function(wrap_pyfunction!(hello_world, m)?)?;
    Ok(())
}

// ...`;

  const exampleProcMacroExpandedOneClean = CODE`\

fn my_library(m: &Bound<'_, PyModule>) -> PyResult<()> {
    let check_gil_refs = ::pyo3::impl_::deprecations::GilRefs::new();
    let m = ::pyo3::impl_::deprecations::inspect_type(m, &check_gil_refs);
    check_gil_refs.function_arg();

    use ::pyo3::{types::PyModuleMethods, PyNativeType};
    m.add_function(wrap_pyfunction!(hello_world, m)?)?;
    Ok(())
}

// ...`;

  const exampleProcMacroExpandedTwo = CODE`\


#[doc(hidden)]
mod my_library {
    #[doc(hidden)]
    pub const __PYO3_NAME: &'static str = concat!(stringify!(my_library), "\\0");
    pub(super) struct MakeDef;
    #[doc(hidden)]
    pub static _PYO3_DEF: ::pyo3::impl_::pymodule::ModuleDef = MakeDef::make_def();
    #[doc = r" This autogenerated function is called by the python interpreter when importing"]
    #[doc = r" the module."]
    #[doc(hidden)]
    #[export_name = "PyInit_my_library"]
    pub unsafe extern "C" fn __pyo3_init() -> *mut ::pyo3::ffi::PyObject {
        ::pyo3::impl_::trampoline::module_init(|py| _PYO3_DEF.make_module(py))
    }
}

// ...`;

  const exampleProcMacroExpandedThree = CODE`\


#[allow(unknown_lints, non_local_definitions)]
impl my_library::MakeDef {
    const fn make_def() -> ::pyo3::impl_::pymodule::ModuleDef {
        fn __pyo3_pymodule(
            module: &::pyo3::Bound<'_, ::pyo3::types::PyModule>,
        ) -> ::pyo3::PyResult<()> {
            my_library(::std::convert::Into::into(
                ::pyo3::impl_::pymethods::BoundRef(module),
            ))
        }
        const INITIALIZER: ::pyo3::impl_::pymodule::ModuleInitializer =
            ::pyo3::impl_::pymodule::ModuleInitializer(__pyo3_pymodule);
        unsafe {
            ::pyo3::impl_::pymodule::ModuleDef::new(my_library::__PYO3_NAME, "\\0", INITIALIZER)
        }
    }
}`;

  yield* codeRef().code.insert([0, 0], exampleProcMacro, 0.6);

  yield* beginSlide("proc_macro_module");

  yield* codeRef().code.remove(lines(0, 6), 1.0);

  yield* beginSlide("proc_macro_expand_one");

  yield* codeRef().code.remove(lines(0), 1.0);
  yield* codeRef().code(exampleProcMacroExpandedOne, 1.0);

  yield* beginSlide("proc_macro_expand_one_clean");

  yield* codeRef().code(exampleProcMacroExpandedOneClean, 1.0);

  yield* beginSlide("proc_macro_expand_one_highlight");

  yield* codeRef().selection(codeRef().findFirstRange(/m.add.*/gi), 0.6);

  yield* beginSlide("proc_macro_expand_one_unhighlight");

  yield* codeRef().selection(DEFAULT, 0.6);

  yield* beginSlide("proc_macro_expand_two");

  yield* chain(
    codeRef().code("// ...", 1.0),
    codeRef().code.append(exampleProcMacroExpandedTwo, 1.0),
  );

  yield* beginSlide("proc_macro_expand_two_clean");

  const rangesToReplace = codeRef().findAllRanges(/.*#\[doc.*/gi);

  yield* all(
    ...rangesToReplace.map((r, index) => (
      chain(
        waitFor(index * 0.2),
        codeRef().code.replace(r, "", 0.6),
      )
    ))
  );

  yield* all(
    codeRef().code.remove(lines(1), 0.6),
    codeRef().code.remove(lines(4), 0.6),
    codeRef().code.remove(lines(9, 10), 0.6),
  );

  const rangesLibName = codeRef().findAllRanges(/#\[export_name.*|my_library/gi);
  const rangeExportName = codeRef().findFirstRange(/#\[export_name.*/gi);
  const rangeExternFn = codeRef().findFirstRange(/pub unsafe extern.*\n.*\n.*/gim);

  yield* beginSlide("proc_macro_expand_two_highlight_lib_name");

  yield* codeRef().selection(rangesLibName, 0.6);

  yield* beginSlide("proc_macro_expand_two_highlight_fn_export");

  yield* codeRef().selection(rangeExportName, 0.6);

  yield* beginSlide("proc_macro_expand_two_highlight_fn_all");

  yield* codeRef().selection([rangeExportName, rangeExternFn], 0.6);

  yield* beginSlide("proc_macro_expand_two_unhighlight");

  yield* codeRef().selection(DEFAULT, 1.0);

  yield* beginSlide("proc_macro_expand_two_highlight_moduledef");

  yield* codeRef().selection(codeRef().findAllRanges(/.*struct.*|pub static.*/gi), 0.6);

  yield* beginSlide("proc_macro_expand_three");

  yield* chain(
    codeRef().selection(DEFAULT, 1.0),
    codeRef().code.remove(lines(0, 13), 1.0),
    codeRef().code.append(exampleProcMacroExpandedThree, 1.0),
  );

  yield* beginSlide("smart_pointers");

  titleTo = "Smart Pointers";
  yield* all(
    codeRef().opacity(0, 2.5),
    title().text("_".repeat(titleTo.length), 1).to(titleTo, 1.5),
  );

  codeRef().code("");

  yield* beginSlide("smart_pointers_lifetime");

  yield* title().text("The 'py Lifetime", 1.5);

  yield* beginSlide("smart_pointers_token");

  yield* title().text("Python<'py>", 1.5);

  yield* beginSlide("smart_pointers_token_code");

  const codeSpToken = CODE`\
Python::with_gil(|py: Python<'py>| {
    // ...
})`;

  let prevLayoutWidth = codeLayoutRef().width();
  let prevFontSize = codeRef().fontSize();

  codeLayoutRef().width("80%");
  codeRef().fontSize(60);
  codeRef().code(codeSpToken);

  yield* all(
    title().text("", 1.5),
    codeRef().opacity(1, 1.5),
  );

  yield* beginSlide("smart_pointers_py");

  yield* all(
    title().text("Py<T>", 1.5),
    codeRef().opacity(0, 1.5),
  );

  yield* beginSlide("smart_pointers_py_desc");

  yield* all(
    displaySubItem(0, " "),
    displaySubItem(1, '"A GIL-independent reference\n to an object allocated\n on the Python heap."', 4.0),
  );

  yield* beginSlide("smart_pointers_py_code");

  yield* all(
    title().text("", 1.5),
    ...range(4).map(n => (hideSubItem(n, 3.0))),
    chain(
      codeRef().opacity(1, 1),
      codeRef().fontSize(prevFontSize, 0.6),
    ),
  );

  yield* beginSlide("smart_pointers_py_code_more");

  const codeSpPyClean = CODE`\
Python::with_gil(|py| {
    // ...
})`;

  const codeSpPyIndented = CODE`\
        Python::with_gil(|py| {
            // ...
        })`;

  const codeSpPyComplete = CODE`\
use pyo3::prelude::*;
use pyo3::types::PyDict;

#[pyclass]
struct Foo {
    inner: Py<PyDict>,
}

#[pymethods]
impl Foo {
    #[new]
    fn __new__() -> Foo {
        Python::with_gil(|py| {
            let dict: Py<PyDict> = PyDict::new_bound(py).unbind();
            Foo { inner: dict }
        })
    }
}`;

  yield* codeRef().code(codeSpPyClean, 0.6);
  yield* codeRef().code(codeSpPyIndented, 0.6);
  yield* codeRef().code(codeSpPyComplete, 0.6);

  yield* beginSlide("smart_pointers_py_highlight_struct");

  yield* codeRef().selection(lines(3, 6), 0.6);

  yield* beginSlide("smart_pointers_py_highlight_token");

  yield* codeRef().selection(lines(10, 16), 0.6);

  yield* beginSlide("smart_pointers_py_unhighlight");

  yield* codeRef().selection(DEFAULT, 0.6);

  yield* beginSlide("smart_pointers_bound");

  yield* all(
    title().text("Bound<'py, T>", 1.5),
    codeRef().opacity(0, 1.5),
  );

  yield* beginSlide("smart_pointers_bound_desc");

  yield* all(
    displaySubItem(0, " "),
    displaySubItem(1, '"A GIL-attached equivalent to Py<T>."', 4.0),
  );

  yield* beginSlide("smart_pointers_bound_code");

  yield* all(
    title().text("", 1.5),
    ...range(4).map(n => (hideSubItem(n, 3.0))),
    chain(
      codeRef().opacity(1, 1),
    ),
  );

  yield* beginSlide("smart_pointers_bound_code_highlight_call");

  yield* codeRef().selection(lines(13), 0.6);

  yield* beginSlide("smart_pointers_bound_code_factor");

  const codeSpBound = CODE`\
use pyo3::prelude::*;
use pyo3::types::PyDict;

#[pyclass]
struct Foo {
    inner: Py<PyDict>,
}

#[pymethods]
impl Foo {
    #[new]
    fn __new__() -> Foo {
        Python::with_gil(|py| {
            let new_bound: Bound<PyDict> = PyDict::new_bound(py);
            let dict: Py<PyDict> = new_bound.unbind();
            Foo { inner: dict }
        })
    }
}`;

  const codeSpBoundReplace = CODE`\
            let new_bound: Bound<PyDict> = PyDict::new_bound(py);
`;
  const codeSpBoundInsert = CODE`\
            let dict: Py<PyDict> = new_bound.unbind();
`;

  yield* chain(
    codeRef().code.replace(lines(13), codeSpBoundReplace, 0.6),
    all(
      codeRef().code.insert([14, 0], codeSpBoundInsert, 0.6),
      codeRef().selection(lines(13, 14), 0.6),
    ),
  );

  yield* beginSlide("smart_pointers_bound_code_use_dict");

  const codeSpBoundDictFoo = CODE`\
            let _ = new_bound.set_item("foo", 1);
`;

  const codeSpBoundDictBar = CODE`\
            let _ = new_bound.set_item("bar", ":)");
`;

  yield* chain(
    all(
      codeRef().code.insert([14, 0], "\n", 0.6),
      codeRef().selection(lines(13, 15), 0.6),
    ),
    all(
      codeRef().code.insert([15, 0], codeSpBoundDictFoo, 0.6),
      codeRef().selection(lines(13, 16), 0.6),
    ),
    all(
      codeRef().code.insert([16, 0], codeSpBoundDictBar, 0.6),
      codeRef().selection(lines(13, 17), 0.6),
    ),
    all(
      codeRef().code.insert([17, 0], "\n", 0.6),
      codeRef().selection(lines(13, 18), 0.6),
    ),
  );

  yield* beginSlide("smart_pointers_bound_code_rebind");

  const codeSpBoundDictRebind = CODE`\
            let _ = dict.bind(py).set_item("baz", 42);
`;

  yield* chain(
    all(
      codeRef().code.insert([19, 0], "\n", 0.6),
      codeRef().selection(lines(13, 19), 0.6),
    ),
    all(
      codeRef().code.insert([20, 0], codeSpBoundDictRebind, 0.6),
      codeRef().selection(lines(13, 20), 0.6),
    ),
    all(
      codeRef().code.insert([21, 0], "\n", 0.6),
      codeRef().selection(lines(13, 21), 0.6),
    ),
  );

  yield* beginSlide("smart_pointers_bount_code_highlight_token");

  yield* codeRef().selection(codeRef().findAllRanges("py").slice(4, 7), 0.6);

  yield* beginSlide("smart_pointers_final");

  yield* codeRef().selection(DEFAULT, 0.6);

  yield* beginSlide("summary");

  yield* all(
    codeRef().opacity(0, 1),
  );

  codeRef().code("");

  yield* chain(
    title().height(DEFAULT, 0),
    title().text("_".repeat("Summary".length), 1),
    title().text("Summary", 1.5),
  );

  yield* beginSlide("summary_item_1");

  yield* all(
    displaySubItem(0, " "),
    displaySubItem(1, " * proc macros are neat"),
  );

  yield* beginSlide("summary_item_2");

  yield* all(
    displaySubItem(2, " * smart pointers bridge memory models")
  );

  yield* beginSlide("questions");

  yield* chain(
    all(
      ...range(4).map(n => (hideSubItem(n)))
    ),
    title().text("Questions?", 1.5),
  );

  yield* beginSlide("next_scene");

  yield* chain(
    title().text(NOBREAK_SPACE, 1.5, easeOutQuad),
    title().height(0, 0),
  );
})
